{"version":3,"sources":["webpack://PasswordQuality/webpack/universalModuleDefinition","webpack://PasswordQuality/webpack/bootstrap","webpack://PasswordQuality/../lib/PopularPasswords.js","webpack://PasswordQuality/../lib/PasswordQuality.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","m_dicts","getMaxLength","iMaxLen","_i","_Object$keys","keys","length","iLen","parseInt","ContainsLength","nLength","IsPopularPassword","password","Error","includes","GetDictSize","load","passwordList","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","iterator","next","done","pw","push","err","reset","_readOnlyError","PatternID","LowerAlpha","UpperAlpha","Digit","Special","High","Other","Dictionary","Repetition","Number","DiffSeq","All","PrintableAsciiSpecial","UpperCase","LowerCase","Digits","HighAnsiChars","ch","sbHighAnsi","String","fromCharCode","apply","Assert","ok","msg","m_lCharTypes","QeCharType","chTypeID","strAlphabet","bIsConsecutive","nChars","_classCallCheck","this","RangeError","TypeID","Alphabet","CharCount","m_chFirst","charCodeAt","m_chLast","CharSize","Math","log2","indexOf","EntropyEncoder","uBaseWeight","uCharWeight","uOccExclThreshold","m_strAlph","m_uBaseWeight","m_uCharWeight","m_uOccExclThreshold","m_dHisto","uOcc","uTotalWeight","_Object$values","values","u","dSize","dTotalWeight","_i2","_Object$values2","uWeight","MultiEntropyEncoder","m_dEncs","ec","_i3","_Object$values3","Reset","chData","Write","_i4","_Object$values4","GetOutputSize","QePatternInstance","iPosition","chPatternID","dblCost","ctSingle","Position","Length","Cost","SingleCharType","QePathState","lPath","Path","GetCharType","nTypes","Contains","ComputePathCost","vPassword","ecPattern","mcData","dblPatternCost","dblDataCost","pi","tChar","PartsEqual","v","x1","x2","ErasePart","chErased","j","AddNumberPattern","vPatterns","sb","strNumber","nZeros","strNonZero","substring","parseFloat","FindPopularPasswords","vLower","toLowerCase","vLeet","str","newstr","DecodeLeetChar","charAt","DecodeLeet","nSubLen","min","PopularPasswords","vSub","EvalAddPopularPasswordPattern","StringClear","pos","count","erased","chLeet","sub","dblCostPerMod","uDictSize","v1","iOffset1","v2","iOffset2","nDist","HammingDist","k","PasswordQuality","strSpecial","nSp","nHi","EnsureInitialized","string","array","stringToArray","bFoundRep","FindRepetitions","FindNumbers","Infinity","dCur","FindDiffSeqs","uw","sqrt","AddEncoder","dblMinCost","tStart","Date","now","sRec","pop","lSubs","lNewPath","_toConsumableArray","sNew","ceil"],"mappings":"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","file":"PasswordQuality.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PasswordQuality\"] = factory();\n\telse\n\t\troot[\"PasswordQuality\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const m_dicts = {};\n\nexport function getMaxLength() {\n  let iMaxLen = 0;\n  for (let iLen of Object.keys(m_dicts)) {\n    if (parseInt(iLen) > iMaxLen) iMaxLen = parseInt(iLen);\n  }\n  return iMaxLen;\n}\n\nexport function ContainsLength(nLength) {\n  return nLength in m_dicts;\n}\n\nexport function IsPopularPassword(password) {\n  if (password == null) throw new Error();\n  if (password.length == 0) { return false; }\n\n  if (!(password.length in m_dicts)) {\n    return false;\n  }\n\n  return m_dicts[password.length].includes(password);\n}\n\nexport function GetDictSize(length) {\n\n  if (!(length in m_dicts)) {\n    return 0;\n  }\n\n  return m_dicts[length].length;\n}\n\nexport function load(passwordList) {\n  for (let pw of passwordList) {\n    if (pw.length in m_dicts) {\n      m_dicts[pw.length].push(pw);\n    } else {\n      m_dicts[pw.length] = [pw];\n    }\n  }\n}\n\nexport function reset() {\n  m_dicts = {}\n}","import * as PopularPasswords from './PopularPasswords.js';\n\nconst PatternID = {\n  LowerAlpha: 'L',\n  UpperAlpha: 'U',\n  Digit: 'D',\n  Special: 'S',\n  High: 'H',\n  Other: 'X',\n\n  Dictionary: 'W',\n  Repetition: 'R',\n  Number: 'N',\n  DiffSeq: 'C',\n\n  All: \"LUDSHXWRNC\"\n};\nconst PrintableAsciiSpecial = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nconst UpperCase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst LowerCase = \"abcdefghijklmnopqrstuvwxyz\";\nconst Digits = \"0123456789\";\nconst HighAnsiChars = (() => {\n  let sbHighAnsi = [], ch;\n  for(ch = 0x00A1; ch <= 0x00AC; ++ch)\n    sbHighAnsi.push(ch);\n  for(ch = 0x00AE; ch < 0x00FF; ++ch)\n    sbHighAnsi.push(ch);\n  sbHighAnsi.push(0x00FF);\n  return String.fromCharCode.apply(null, sbHighAnsi);\n})();\n\nfunction Assert(ok, msg) {\n  if (!ok) {\n    throw new Error(msg);\n  }\n}\n\n\nclass QeCharType {\n  constructor(chTypeID, strAlphabet, bIsConsecutive) {\n    let nChars;\n    if (typeof strAlphabet === 'string') {\n      if(strAlphabet.length === 0) throw new Error();\n    } else if (typeof strAlphabet === 'number') {\n      if(nChars <= 0) throw new RangeError();\n      nChars = strAlphabet;\n      strAlphabet = null;\n      bIsConsecutive = false;\n    } else {\n      throw new Error();\n    }\n\n    this.TypeID = chTypeID;\n    this.Alphabet = strAlphabet;\n    this.CharCount = nChars || this.Alphabet.length;\n    this.m_chFirst = (bIsConsecutive ? this.Alphabet.charCodeAt(0) : null);\n    this.m_chLast = (bIsConsecutive ? this.Alphabet.charCodeAt(this.CharCount - 1) : null);\n\n    this.CharSize = Math.log2(this.CharCount);\n    nChars || Assert((this.m_chLast - this.m_chFirst) == (this.CharCount - 1) || !bIsConsecutive);\n  }\n\n  Contains(ch)\n  {\n    if(this.m_chLast !== null)\n      return ((ch >= this.m_chFirst) && (ch <= this.m_chLast));\n\n    if (this.Alphabet.length === 0) throw new Error('Don\\'t call for catch-none set')\n    return (this.Alphabet.indexOf(String.fromCharCode(ch)) >= 0);\n  }\n}\n\nclass EntropyEncoder {\n  constructor(strAlphabet, uBaseWeight,\n    uCharWeight, uOccExclThreshold)\n  {\n    if(strAlphabet === null || strAlphabet.length === 0) throw new Error();\n\n    this.m_strAlph = strAlphabet;\n    this.m_uBaseWeight = uBaseWeight;\n    this.m_uCharWeight = uCharWeight;\n    this.m_uOccExclThreshold = uOccExclThreshold;\n\n    this.m_dHisto = {}\n  }\n\n  Reset()\n  {\n    this.m_dHisto = {};\n  }\n\n\tWrite(ch)\n  {\n    Assert(this.m_strAlph.indexOf(ch) >= 0);\n\n    let uOcc = this.m_dHisto[ch] || 0;\n    Assert(ch in this.m_dHisto || uOcc === 0);\n    this.m_dHisto[ch] = uOcc + 1;\n  }\n\n  GetOutputSize()\n  {\n    let uTotalWeight = this.m_uBaseWeight * this.m_strAlph.length;\n    for (let u of Object.values(this.m_dHisto))\n    {\n      Assert(u >= 1);\n      if(u > this.m_uOccExclThreshold)\n        uTotalWeight += (u - this.m_uOccExclThreshold) * this.m_uCharWeight;\n    }\n\n    let dSize = 0.0, dTotalWeight = uTotalWeight;\n    for (let u of Object.values(this.m_dHisto))\n    {\n      let uWeight = this.m_uBaseWeight;\n      if(u > this.m_uOccExclThreshold)\n        uWeight += (u - this.m_uOccExclThreshold) * this.m_uCharWeight;\n\n      dSize -= u * Math.log2(uWeight / dTotalWeight);\n    }\n\n    return dSize;\n  }\n}\n\nclass MultiEntropyEncoder {\n  constructor() {\n    this.m_dEncs = {};\n  }\n\n  AddEncoder(chTypeID, ec)\n  {\n    Assert(ec);\n\n    Assert(!(chTypeID in this.m_dEncs));\n    this.m_dEncs[chTypeID] = ec;\n  }\n\n  Reset()\n  {\n    for(let ec of Object.values(this.m_dEncs)) {\n      ec.Reset();\n    }\n  }\n\n  Write(chTypeID, chData)\n  {\n    let ec = this.m_dEncs[chTypeID];\n    if(!ec)\n      return false;\n\n    ec.Write(chData);\n    return true;\n  }\n\n  GetOutputSize()\n  {\n    let d = 0.0;\n\n    for (let ec of Object.values(this.m_dEncs))\n    {\n      d += ec.GetOutputSize();\n    }\n\n    return d;\n  }\n}\n\nclass QePatternInstance\n{\n  constructor(iPosition, nLength, chPatternID, dblCost) {\n    let ctSingle;\n    if (typeof dblCost === 'number') {\n      this.Position = iPosition;\n      this.Length = nLength;\n      this.PatternID = chPatternID;\n      this.Cost = dblCost;\n      this.SingleCharType = null;\n    } else {\n      ctSingle = chPatternID;\n\n      this.Position = iPosition;\n      this.Length = nLength;\n      this.PatternID = ctSingle.TypeID;\n      this.Cost = ctSingle.CharSize;\n      this.SingleCharType = ctSingle;\n    }\n  }\n}\n\nclass QePathState {\n  constructor(iPosition, lPath) {\n    this.Position = iPosition;\n    this.Path = lPath;\n  }\n}\n\nlet m_objSyncInit;\nlet m_lCharTypes;\n\nfunction EnsureInitialized() {\n  if(m_lCharTypes == null)\n  {\n    let strSpecial = PrintableAsciiSpecial;\n    strSpecial = strSpecial + \" \";\n\n    let nSp = strSpecial.length;\n    let nHi = HighAnsiChars.length;\n\n    m_lCharTypes = [];\n\n    m_lCharTypes.push(new QeCharType(PatternID.LowerAlpha,\n      LowerCase, true));\n    m_lCharTypes.push(new QeCharType(PatternID.UpperAlpha,\n      UpperCase, true));\n    m_lCharTypes.push(new QeCharType(PatternID.Digit,\n      Digits, true));\n    m_lCharTypes.push(new QeCharType(PatternID.Special,\n      strSpecial, false));\n    m_lCharTypes.push(new QeCharType(PatternID.High,\n      HighAnsiChars, false));\n    m_lCharTypes.push(new QeCharType(PatternID.Other,\n      0x10000 - (2 * 26) - 10 - nSp - nHi));\n  }\n}\n\nfunction GetCharType(ch) {\n  let nTypes = m_lCharTypes.length;\n  Assert((nTypes > 0) && (m_lCharTypes[nTypes - 1].CharCount > 256));\n\n  for(let i = 0; i < (nTypes - 1); ++i)\n  {\n    if(m_lCharTypes[i].Contains(ch))\n      return m_lCharTypes[i];\n  }\n\n  return m_lCharTypes[nTypes - 1];\n}\n\nfunction ComputePathCost(l, vPassword, ecPattern, mcData)\n{\n  ecPattern.Reset();\n  for(let i = 0; i < l.length; ++i)\n    ecPattern.Write(l[i].PatternID);\n  let dblPatternCost = ecPattern.GetOutputSize();\n\n  mcData.Reset();\n  let dblDataCost = 0.0;\n  for(let pi of l)\n  {\n    let tChar = pi.SingleCharType;\n    if(tChar != null)\n    {\n      let ch = vPassword[pi.Position];\n      if(!mcData.Write(tChar.TypeID, ch))\n        dblDataCost += pi.Cost;\n    }\n    else dblDataCost += pi.Cost;\n  }\n  dblDataCost += mcData.GetOutputSize();\n\n  return (dblPatternCost + dblDataCost);\n}\n\nfunction FindRepetitions(vPassword, vPatterns)\n{\n  let v = stringToArray(vPassword);\n  let n = vPassword.length;\n\n  let chErased = 0xffff;\n  for(let m = (n / 2); m >= 3; --m)\n  {\n    for(let x1 = 0; x1 <= (n - (2 * m)); ++x1)\n    {\n      let bFoundRep = false;\n\n      for(let x2 = (x1 + m); x2 <= (n - m); ++x2)\n      {\n        if(PartsEqual(v, x1, x2, m))\n        {\n          let dblCost = Math.log2(x1 + 1) + Math.log2(m);\n          vPatterns[x2].push(new QePatternInstance(x2, m,\n            PatternID.Repetition, dblCost));\n\n          chErased = ErasePart(v, x2, m, chErased);\n\n          bFoundRep = true;\n        }\n      }\n\n      if (bFoundRep) chErased = ErasePart(v, x1, m, chErased);\n    }\n  }\n}\n\nfunction PartsEqual(v, x1, x2, nLength)\n{\n  for(let i = 0; i < nLength; ++i)\n  {\n    if(v[x1 + i] != v[x2 + i]) return false;\n  }\n\n  return true;\n}\n\nfunction ErasePart(v, i, n, chErased)\n{\n  for(let j = 0; j < n; ++j) {\n    v[i + j] = chErased;\n    --chErased;\n  }\n\n  return chErased;\n}\n\nfunction stringToArray(string) {\n  let array = [];\n  for (let i = 0; i < string.length; i++) {\n    array.push(string.charCodeAt(i));\n  }\n  return array;\n}\n\nfunction FindNumbers(vPassword, vPatterns)\n{\n  let n = vPassword.length;\n  let sb = [];\n\n  for(let i = 0; i < n; ++i)\n  {\n    let ch = vPassword.charCodeAt(i);\n    if((ch >= 0x30) && (ch <= 0x39)) sb.push(ch);\n    else\n    {\n      AddNumberPattern(vPatterns, sb, i - sb.length);\n      sb = [];\n    }\n  }\n  AddNumberPattern(vPatterns, sb, n - sb.length);\n}\n\nfunction AddNumberPattern(vPatterns, sb, i)\n{\n  if(sb.length <= 2) return;\n  let strNumber = String.fromCharCode.apply(null,sb);\n\n  let nZeros = 0;\n  for(let j = 0; j < strNumber.length; ++j)\n  {\n    if(strNumber.charCodeAt(j) != 0x30) break;\n    ++nZeros;\n  }\n\n  let dblCost = Math.log2(nZeros + 1);\n  if(nZeros < strNumber.length)\n  {\n    let strNonZero = strNumber.substring(nZeros);\n\n    dblCost += Math.log2(parseFloat(strNonZero));\n  }\n\n  vPatterns[i].push(new QePatternInstance(i, strNumber.length,\n    PatternID.Number, dblCost));\n}\n\nfunction FindDiffSeqs(vPassword, vPatterns) {\n  let n = vPassword.length;\n  let d = Infinity, p = 0;\n\n  for(let i = 1; i <= n; ++i)\n  {\n    let dCur = ((i == n) ? Infinity :\n      (vPassword.charCodeAt(i) - vPassword.charCodeAt(i - 1)));\n    if(dCur != d)\n    {\n      if((i - p) >= 3) // At least 3 chars involved\n      {\n        let ct = GetCharType(vPassword.charCodeAt(p));\n        let dblCost = ct.CharSize + Math.log2(i - p - 1);\n\n        vPatterns[p].push(new QePatternInstance(p,\n          i - p, PatternID.DiffSeq, dblCost));\n      }\n\n      d = dCur;\n      p = i - 1;\n    }\n  }\n}\n\nfunction DecodeLeet(str) {\n  let newstr = '';\n  for (let i = 0; i < str.length; i++) {\n    let char = str.charAt(i);\n    let decoded = DecodeLeetChar(char);\n    newstr += decoded;\n  }\n  return newstr;\n}\n\nfunction FindPopularPasswords(vPassword, vPatterns) {\n  let n = vPassword.length;\n\n  let vLower = vPassword.toLowerCase();\n  let vLeet = DecodeLeet(vLower);\n\n  for(let nSubLen = Math.min(n, PopularPasswords.getMaxLength()); nSubLen >= 3; --nSubLen) {\n    if (!PopularPasswords.ContainsLength(nSubLen)) continue;\n\n    for(let i = 0; i <= (n - nSubLen); ++i)\n\t\t{\n      let vSub = vLower.substring(i, i + nSubLen);\n\n      if (!vSub || vSub.indexOf('\\u0000') !== -1) {\n        continue;\n      }\n\n      if(!EvalAddPopularPasswordPattern(vPatterns, vPassword,\n        i, vSub, 0.0))\n      {\n        let vLeetSub = vLeet.substring(i, nSubLen);\n        if(EvalAddPopularPasswordPattern(vPatterns, vPassword,\n          i, vLeetSub, 1.5))\n        {\n          vLower = StringClear(vLower, i, nSubLen); // Not vLeet\n        }\n      }\n      else\n      {\n        vLower = StringClear(vLower, i, nSubLen); // Not vLeet\n      }\n    }\n  }\n}\n\nfunction StringClear(str, pos, count) {\n  let erased = ''\n  for (let i = 0;i < count;i++) {\n    erased += '\\u0000'\n  }\n  return str.substring(0, pos) + erased + str.substring(pos + count);\n}\n\nfunction DecodeLeetChar(chLeet) {\n  if((chLeet.charCodeAt(0) >= 0x00C0) && (chLeet.charCodeAt(0) <= 0x00C6)) return 'a';\n  if((chLeet.charCodeAt(0) >= 0x00C8) && (chLeet.charCodeAt(0) <= 0x00CB)) return 'e';\n  if((chLeet.charCodeAt(0) >= 0x00CC) && (chLeet.charCodeAt(0) <= 0x00CF)) return 'i';\n  if((chLeet.charCodeAt(0) >= 0x00D2) && (chLeet.charCodeAt(0) <= 0x00D6)) return 'o';\n  if((chLeet.charCodeAt(0) >= 0x00D9) && (chLeet.charCodeAt(0) <= 0x00DC)) return 'u';\n  if((chLeet.charCodeAt(0) >= 0x00E0) && (chLeet.charCodeAt(0) <= 0x00E6)) return 'a';\n  if((chLeet.charCodeAt(0) >= 0x00E8) && (chLeet.charCodeAt(0) <= 0x00EB)) return 'e';\n  if((chLeet.charCodeAt(0) >= 0x00EC) && (chLeet.charCodeAt(0) <= 0x00EF)) return 'i';\n  if((chLeet.charCodeAt(0) >= 0x00F2) && (chLeet.charCodeAt(0) <= 0x00F6)) return 'o';\n  if((chLeet.charCodeAt(0) >= 0x00F9) && (chLeet.charCodeAt(0) <= 0x00FC)) return 'u';\n\n  switch(chLeet)\n  {\n    case '4':\n    case '@':\n    case '?':\n    case '^':\n    case '\\u00AA': return 'a';\n    case '8':\n    case '\\u00DF': return 'b';\n    case '(':\n    case '{':\n    case '[':\n    case '<':\n    case '\\u00A2':\n    case '\\u00A9':\n    case '\\u00C7':\n    case '\\u00E7': return 'c';\n    case '\\u00D0':\n    case '\\u00F0': return 'd';\n    case '3':\n    case '\\u20AC':\n    case '&':\n    case '\\u00A3': return 'e';\n    case '6':\n    case '9': return 'g';\n    case '#': return 'h';\n    case '1':\n    case '!':\n    case '|':\n    case '\\u00A1':\n    case '\\u00A6': return 'i';\n    case '\\u00D1':\n    case '\\u00F1': return 'n';\n    case '0':\n    case '*':\n    case '\\u00A4': // Currency\n    case '\\u00B0': // Degree\n    case '\\u00D8':\n    case '\\u00F8': return 'o';\n    case '\\u00AE': return 'r';\n    case '$':\n    case '5':\n    case '\\u00A7': return 's';\n    case '+':\n    case '7': return 't';\n    case '\\u00B5': return 'u';\n    case '%':\n    case '\\u00D7': return 'x';\n    case '\\u00A5':\n    case '\\u00DD':\n    case '\\u00FD':\n    case '\\u00FF': return 'y';\n    case '2': return 'z';\n    default: return chLeet;\n  }\n}\n\nfunction EvalAddPopularPasswordPattern(vPatterns, vPassword, i, sub, dblCostPerMod)\n{\n  let IsPopularPassword = PopularPasswords.IsPopularPassword(sub);\n  let uDictSize = PopularPasswords.GetDictSize(sub.length);\n  if(!IsPopularPassword)\n    return false;\n\n  let n = sub.length;\n  let d = HammingDist(sub, 0, vPassword, i, n);\n\n  let dblCost = Math.log2(uDictSize);\n\n  // dblCost += Math.log2(n binom d)\n  let k = Math.min(d, n - d);\n  for(let j = n; j > (n - k); --j)\n    dblCost += Math.log2(j);\n  for(let j = k; j >= 2; --j)\n    dblCost -= Math.log2(j);\n\n  dblCost += dblCostPerMod * d;\n\n  vPatterns[i].push(new QePatternInstance(i, n, PatternID.Dictionary,\n    dblCost));\n  return true;\n}\n\nfunction HammingDist(v1, iOffset1, v2, iOffset2, nLength)\n{\n  let nDist = 0;\n  for(let i = 0; i < nLength; ++i)\n  {\n    if(v1.charCodeAt(iOffset1 + i) !== v2.charCodeAt(iOffset2 + i)) ++nDist;\n  }\n\n  return nDist;\n}\n\nexport default function PasswordQuality(vPassword)\n{\n  if (typeof vPassword !== 'string' || vPassword.length === 0) return 0;\n\n  EnsureInitialized();\n\n  let n = vPassword.length;\n  let vPatterns = [];\n\n  for (let i = 0; i < n; i++) {\n    vPatterns[i] = [\n      new QePatternInstance(i, 1, GetCharType(vPassword.charCodeAt(i)))\n    ];\n  }\n\n  FindRepetitions(vPassword, vPatterns);\n  FindNumbers(vPassword, vPatterns);\n  FindDiffSeqs(vPassword, vPatterns);\n  FindPopularPasswords(vPassword, vPatterns);\n\n  // Encoders must not be static, because the entropy estimation\n  // may run concurrently in multiple threads and the encoders are\n  // not read-only\n  let ecPattern = new EntropyEncoder(PatternID.All, 0, 1, 0);\n  let mcData = new MultiEntropyEncoder();\n\n  for(let i = 0; i < (m_lCharTypes.length - 1); ++i)\n  {\n    // Let m be the alphabet size. In order to ensure that two same\n    // characters cost at least as much as a single character, for\n    // the probability p and weight w of the character it must hold:\n    //     -log(1/m) >= -2*log(p)\n    // <=> log(1/m) <= log(p^2) <=> 1/m <= p^2 <=> p >= sqrt(1/m);\n    //     sqrt(1/m) = (1+w)/(m+w)\n    // <=> m+w = (1+w)*sqrt(m) <=> m+w = sqrt(m) + w*sqrt(m)\n    // <=> w*(1-sqrt(m)) = sqrt(m) - m <=> w = (sqrt(m)-m)/(1-sqrt(m))\n    // <=> w = (sqrt(m)-m)*(1+sqrt(m))/(1-m)\n    // <=> w = (sqrt(m)-m+m-m*sqrt(m))/(1-m) <=> w = sqrt(m)\n    let uw = Math.sqrt(m_lCharTypes[i].CharCount) | 0;\n\n    mcData.AddEncoder(m_lCharTypes[i].TypeID, new EntropyEncoder(\n      m_lCharTypes[i].Alphabet, 1, uw, 1));\n  }\n\n  let dblMinCost = Infinity;\n  let tStart = Date.now();\n  \n  let sRec = [];\n  sRec.push(new QePathState(0, []));\n\n\n  while(sRec.length > 0)\n  {\n    let tDiff = Date.now() - tStart;\n    if(tDiff > 500) break;\n\n    let s = sRec.pop();\n\n    if(s.Position >= n)\n    {\n      Assert(s.Position === n);\n\n      let dblCost = ComputePathCost(s.Path, vPassword,\n        ecPattern, mcData);\n      if(dblCost < dblMinCost) dblMinCost = dblCost;\n    }\n    else\n    {\n      let lSubs = vPatterns[s.Position];\n      for(let i = lSubs.length - 1; i >= 0; --i)\n      {\n        let pi = lSubs[i];\n        Assert(pi.Position == s.Position);\n        Assert(pi.Length >= 1);\n\n        let lNewPath = [];\n        lNewPath.push(...s.Path);\n        lNewPath.push(pi);\n\n        let sNew = new QePathState(s.Position +\n          pi.Length, lNewPath);\n        sRec.push(sNew);\n      }\n    }\n  }\n\n  return Math.ceil(dblMinCost);\n}\n\nPasswordQuality.PopularPasswords = PopularPasswords;"],"sourceRoot":""}